#pragma once

namespace CodeRed {
	constexpr char DxEffectPassVertexShaderCode[] = "#pragma pack_matrix(row_major) \n \n#define MAX_LIGHTS_PER_TYPE 16 \n#define MAX_ALL_LIGHTS MAX_LIGHTS_PER_TYPE * 3 \n#define MAX_MATERIALS MAX_LIGHTS_PER_TYPE \n#define MAX_TRANSFORMS MAX_LIGHTS_PER_TYPE \n \nstruct Transform3D \n{ \n    matrix NormalTransform; \n    matrix Projection; \n    matrix Transform; \n    matrix View; \n}; \n \nstruct Transforms  \n{ \n    Transform3D instance[MAX_TRANSFORMS]; \n}; \n \nstruct Index \n{ \n	uint materialIndex; \n	uint transformIndex; \n	float ambientLightRed; \n	float ambientLightGreen; \n	float ambientLightBlue; \n	float ambientLightAlpha; \n}; \n \nstruct Output \n{ \n    float3 ViewPosition : POSITION0; \n    float4 SVPosition : SV_POSITION; \n    float3 Position : POSITION1; \n    float3 Normal : NORMAL; \n}; \n \nConstantBuffer<Transforms> transforms : register(b2, space0); \nConstantBuffer<Index> index : register(b3, space0);  \n \nOutput main( \n    float3 position : POSITION, \n    float3 normal : NORMAL) \n{ \n    Output result; \n \n    uint transformIndex = index.transformIndex; \n \n    result.Position = mul(float4(position, 1.0f), transforms.instance[transformIndex].Transform).xyz; \n    result.ViewPosition = mul(float4(result.Position, 1.0f), transforms.instance[transformIndex].View).xyz; \n    result.SVPosition = mul(float4(result.ViewPosition, 1.0f), transforms.instance[transformIndex].Projection); \n    result.Normal = mul(float4(normal, 1.0f), transforms.instance[transformIndex].NormalTransform).xyz; \n     \n    return result; \n}\n";
	constexpr char DxEffectPassPixelShaderCode[] = "#pragma pack_matrix(row_major) \n \n#define MAX_LIGHTS_PER_TYPE 16 \n#define MAX_ALL_LIGHTS MAX_LIGHTS_PER_TYPE * 3 \n#define MAX_MATERIALS MAX_LIGHTS_PER_TYPE \n#define MAX_TRANSFORMS MAX_LIGHTS_PER_TYPE \n \nstruct Material \n{ \n    float4 DiffuseAlbedo; \n    float3 FresnelR0; \n    float Roughness; \n}; \n \nstruct Light { \n    float3 Strength; \n    float FalloffStart;  \n    float3 Direction;  \n    float FalloffEnd;  \n    float3 Position;  \n    float SpotPower;  \n}; \n \nfloat CalcAttenuation(float d, float falloffStart, float falloffEnd) \n{ \n    return saturate((falloffEnd - d) / (falloffEnd - falloffStart)); \n} \n \nfloat3 SchlickFresnel(float3 R0, float3 normal, float3 lightVector){ \n    float cosIncidentAngle = saturate(dot(normal, lightVector)); \n \n    float f0 = 1.0f - cosIncidentAngle; \n    float3 reflectPercent = R0 + (1.0f - R0) * (f0 * f0 * f0 * f0 * f0); \n \n    return reflectPercent; \n} \n \nfloat3 BlinnPhong(float3 lightStrength, float3 lightVector, float3 normal, float3 toEye, Material material) \n{ \n    const float m = (1.0f - material.Roughness) * 256.0f; \n    float3 halfVec = normalize(toEye + lightVector); \n \n    float roughnessFactor = (m + 8.0f) * pow(max(dot(halfVec, normal), 0.0f), m) / 8.0f; \n    float3 fresnelFactor = SchlickFresnel(material.FresnelR0, halfVec, lightVector); \n    float3 specAlbedo = fresnelFactor * roughnessFactor; \n \n    specAlbedo = specAlbedo / (specAlbedo + 1.0f); \n \n    return (material.DiffuseAlbedo.rgb + specAlbedo) * lightStrength; \n} \n \nfloat3 ComputeDirectionalLight(Light light, Material material, float3 normal, float3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = -light.Direction; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nfloat3 ComputePointLight(Light light, Material material, float3 position, float3 normal, float3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return float3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n \n    lightStrength = lightStrength * att; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nfloat3 ComputeSpotLight(Light light, Material material, float3 position, float3 normal, float3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return float3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n    lightStrength = lightStrength * att; \n \n    float spotFactor = pow(max(dot(-lightVector, light.Direction), 0.0f), light.SpotPower); \n \n    lightStrength = lightStrength * spotFactor; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nfloat4 ComputeLighting(Light lights[MAX_ALL_LIGHTS], Material material, float3 position, float3 normal, float3 toEye) \n{ \n    normal = normalize(normal); \n \n    float3 result = float3(0.0f, 0.0f, 0.0f); \n \n    for (int i = 0; i < MAX_LIGHTS_PER_TYPE; i++) \n    { \n        result = result + ComputeDirectionalLight(lights[0 * MAX_LIGHTS_PER_TYPE + i], material, normal, toEye); \n        result = result + ComputePointLight(lights[1 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye); \n        result = result + ComputeSpotLight(lights[2 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye); \n    } \n \n    return float4(result.xyz, material.DiffuseAlbedo.a); \n} \n \nstruct Lights \n{ \n    Light instance[MAX_ALL_LIGHTS]; \n}; \n \nstruct Materials \n{ \n    Material instance[MAX_MATERIALS]; \n}; \n \nstruct Index \n{ \n    uint materialIndex; \n    uint transformIndex; \n	float ambientLightRed; \n	float ambientLightGreen; \n	float ambientLightBlue; \n	float ambientLightAlpha; \n}; \n \nConstantBuffer<Lights> lights : register(b0, space0); \nConstantBuffer<Materials> materials : register(b1, space0); \nConstantBuffer<Index> index : register(b3, space0); \n \nfloat4 main( \n    float3 viewPosition : POSITION0, \n    float4 sVPosition : SV_POSITION, \n    float3 position : POSITION1, \n    float3 normal : NORMAL) : SV_TARGET \n{ \n    uint materialIndex = index.materialIndex; \n     \n    float3 toEye = float3(0.0f, 0.0f, 0.0f) - viewPosition; \n     \n	float4 ambient = float4( \n		index.ambientLightRed,  \n		index.ambientLightGreen,  \n		index.ambientLightBlue,  \n		index.ambientLightAlpha) * materials.instance[materialIndex].DiffuseAlbedo; \n \n    float4 color = ComputeLighting(lights.instance, materials.instance[materialIndex], \n        position, normal, toEye) + ambient; \n \n	return float4(color.xyz, materials.instance[materialIndex].DiffuseAlbedo.a); \n}\n";

}