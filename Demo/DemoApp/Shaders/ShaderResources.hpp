#pragma once

namespace CodeRed {
	constexpr char DxGeneralEffectPassVertexShaderCode[] = "#pragma pack_matrix(row_major) \n \nstruct Transform3D \n{ \n    matrix NormalTransform; \n    matrix Projection; \n    matrix Transform; \n    matrix View; \n	float4 EyePosition; \n}; \n \nstruct Output \n{ \n    float3 ViewPosition : POSITION0; \n    float4 SVPosition : SV_POSITION; \n    float3 Position : POSITION1; \n    float3 Normal : NORMAL; \n	float2 Texcoord : TEXCOORD; \n    float3 Tangent : TANGENT; \n	uint   InstanceId : SV_INSTANCEID; \n}; \n \nStructuredBuffer<Transform3D> transforms : register(t2, space0); \n \nOutput main( \n    float3 position : POSITION, \n    float3 normal : NORMAL, \n	float2 texcoord : TEXCOORD, \n    float3 tangent : TANGENT, \n	uint   instanceId : SV_INSTANCEID) \n{ \n    Output result; \n \n    result.Position = mul(float4(position, 1.0f), transforms[instanceId].Transform).xyz; \n    result.ViewPosition = mul(float4(result.Position, 1.0f), transforms[instanceId].View).xyz; \n    result.SVPosition = mul(float4(result.ViewPosition, 1.0f), transforms[instanceId].Projection); \n    result.Normal = mul(normal, (float3x3)transforms[instanceId].NormalTransform); \n    result.Tangent = mul(tangent, (float3x3)transforms[instanceId].NormalTransform); \n	result.Texcoord = texcoord; \n	result.InstanceId = instanceId; \n \n    return result; \n}\n";
	constexpr char VkGeneralEffectPassVertexShaderCode[] = "#version 450 \n \n#extension GL_ARB_separate_shader_objects : enable \n \nstruct Transform3D \n{ \n    mat4 NormalTransform; \n    mat4 Projection; \n    mat4 Transform; \n    mat4 View; \n    vec4 EyePosition; \n}; \n \nlayout (set = 0, binding = 2) buffer Transform \n{ \n    Transform3D instance[]; \n} transforms; \n \nlayout (location = 0) in vec3 position; \nlayout (location = 1) in vec3 normal; \nlayout (location = 2) in vec2 texcoord; \nlayout (location = 3) in vec3 tangent; \n \nlayout (location = 0) out vec3 outViewPosition; \nlayout (location = 1) out vec3 outPosition; \nlayout (location = 2) out vec3 outNormal; \nlayout (location = 3) out vec2 outTexcoord; \nlayout (location = 4) out vec3 outTangent; \nlayout (location = 5) out uint outInstanceId; \n \nvoid main() \n{ \n    Transform3D transform = transforms.instance[gl_InstanceIndex]; \n \n    outPosition = (transform.Transform * vec4(position, 1.0)).xyz; \n    outViewPosition = (transform.View * vec4(outPosition, 1.0)).xyz; \n    outNormal = mat3(transform.NormalTransform) * normal; \n    outTangent = mat3(transform.NormalTransform) * tangent; \n    outTexcoord = texcoord; \n    outInstanceId = gl_InstanceIndex; \n \n    gl_Position = transform.Projection * vec4(outViewPosition, 1.0f); \n    gl_Position.y = -gl_Position.y; \n}\n";
	constexpr char DxGeneralEffectPassPixelShaderCode[] = "#pragma pack_matrix(row_major) \n \n#define MAX_LIGHTS_PER_TYPE 16 \n#define MAX_ALL_LIGHTS MAX_LIGHTS_PER_TYPE * 3 \n \nstruct Material \n{ \n    float4 DiffuseAlbedo; \n    float3 FresnelR0; \n    float Roughness; \n}; \n \nstruct Light { \n    float3 Strength; \n    float FalloffStart;  \n    float3 Direction;  \n    float FalloffEnd;  \n    float3 Position;  \n    float SpotPower;  \n}; \n \nstruct Transform3D \n{ \n	matrix NormalTransform; \n	matrix Projection; \n	matrix Transform; \n	matrix View; \n	float4 EyePosition; \n}; \n \nfloat CalcAttenuation(float d, float falloffStart, float falloffEnd) \n{ \n    return saturate((falloffEnd - d) / (falloffEnd - falloffStart)); \n} \n \nfloat3 SchlickFresnel(float3 R0, float3 normal, float3 lightVector){ \n    float cosIncidentAngle = saturate(dot(normal, lightVector)); \n \n    float f0 = 1.0f - cosIncidentAngle; \n    float3 reflectPercent = R0 + (1.0f - R0) * (f0 * f0 * f0 * f0 * f0); \n \n    return reflectPercent; \n} \n \nfloat3 BlinnPhong(float3 lightStrength, float3 lightVector, float3 normal, float3 toEye, Material material) \n{ \n	//see https://github.com/d3dcoder/d3d12book to learn more about Blinn Phong \n    const float m = (1.0f - material.Roughness) * 256.0f; \n    float3 halfVec = normalize(toEye + lightVector); \n \n    float roughnessFactor = (m + 8.0f) * pow(max(dot(halfVec, normal), 0.0f), m) / 8.0f; \n    float3 fresnelFactor = SchlickFresnel(material.FresnelR0, halfVec, lightVector); \n    float3 specAlbedo = fresnelFactor * roughnessFactor; \n \n    specAlbedo = specAlbedo / (specAlbedo + 1.0f); \n \n    return (material.DiffuseAlbedo.rgb + specAlbedo) * lightStrength; \n} \n \nfloat3 ComputeDirectionalLight(Light light, Material material, float3 normal, float3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = -light.Direction; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nfloat3 ComputePointLight(Light light, Material material, float3 position, float3 normal, float3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return float3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n \n    lightStrength = lightStrength * att; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nfloat3 ComputeSpotLight(Light light, Material material, float3 position, float3 normal, float3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return float3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n    lightStrength = lightStrength * att; \n \n    float spotFactor = pow(max(dot(-lightVector, light.Direction), 0.0f), light.SpotPower); \n \n    lightStrength = lightStrength * spotFactor; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nfloat4 ComputeLighting(Light lights[MAX_ALL_LIGHTS], Material material, float3 position, float3 normal, float3 toEye) \n{ \n    normal = normalize(normal); \n \n    float3 result = float3(0.0f, 0.0f, 0.0f); \n \n    for (int i = 0; i < MAX_LIGHTS_PER_TYPE; i++) \n    { \n        result = result + ComputeDirectionalLight(lights[0 * MAX_LIGHTS_PER_TYPE + i], material, normal, toEye); \n        result = result + ComputePointLight(lights[1 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye); \n        result = result + ComputeSpotLight(lights[2 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye); \n    } \n \n    return float4(result.xyz, material.DiffuseAlbedo.a); \n} \n \nstruct Lights \n{ \n    Light instance[MAX_ALL_LIGHTS]; \n}; \n \nstruct Index \n{ \n	float ambientLightRed; \n	float ambientLightGreen; \n	float ambientLightBlue; \n	float ambientLightAlpha; \n}; \n \nStructuredBuffer<Transform3D> transforms : register(t2, space0); \nStructuredBuffer<Material> materials : register(t1, space0); \n \nConstantBuffer<Lights> lights : register(b0, space0); \nConstantBuffer<Index> index : register(b9, space0); \n \nSamplerState materialSampler : register(s8, space0); \n \nfloat4 main( \n    float3 viewPosition : POSITION0, \n    float4 sVPosition : SV_POSITION, \n    float3 position : POSITION1, \n    float3 normal : NORMAL, \n	float2 texcoord : TEXCOORD, \n    float3 tangent : TANGENT, \n	uint   instanceId : SV_INSTANCEID) : SV_TARGET \n{ \n    float3 toEye = normalize(transforms[instanceId].EyePosition.xyz - position); \n     \n	float4 ambient = float4( \n		index.ambientLightRed,  \n		index.ambientLightGreen,  \n		index.ambientLightBlue,  \n		index.ambientLightAlpha) * materials[instanceId].DiffuseAlbedo; \n \n    float4 color = ComputeLighting(lights.instance, materials[instanceId], \n        position, normal, toEye) + ambient; \n \n	return float4(color.xyz, materials[instanceId].DiffuseAlbedo.a); \n}\n";
	constexpr char VkGeneralEffectPassPixelShaderCode[] = "#version 450 \n \n#extension GL_ARB_separate_shader_objects : enable \n \n#define MAX_LIGHTS_PER_TYPE 16 \n#define MAX_ALL_LIGHTS MAX_LIGHTS_PER_TYPE * 3 \n \nstruct Material \n{ \n    vec4 DiffuseAlbedo; \n    vec3 FresnelR0; \n    float Roughness; \n}; \n \nstruct Light { \n    vec3 Strength; \n    float FalloffStart;  \n    vec3 Direction;  \n    float FalloffEnd;  \n    vec3 Position;  \n    float SpotPower;  \n}; \n \nstruct Transform3D \n{ \n    mat4 NormalTransform; \n    mat4 Projection; \n    mat4 Transform; \n    mat4 View; \n    vec4 EyePosition; \n}; \n \nfloat CalcAttenuation(float d, float falloffStart, float falloffEnd) \n{ \n    return clamp((falloffEnd - d) / (falloffEnd - falloffStart), 0, 1); \n} \n \nvec3 SchlickFresnel(vec3 R0, vec3 normal, vec3 lightVector){ \n    float cosIncidentAngle = clamp(dot(normal, lightVector), 0, 1); \n \n    float f0 = 1.0f - cosIncidentAngle; \n    vec3 reflectPercent = R0 + (1.0f - R0) * (f0 * f0 * f0 * f0 * f0); \n \n    return reflectPercent; \n} \n \nvec3 BlinnPhong(vec3 lightStrength, vec3 lightVector, vec3 normal, vec3 toEye, Material material) \n{ \n	//see https://github.com/d3dcoder/d3d12book to learn more about Blinn Phong \n    const float m = (1.0f - material.Roughness) * 256.0f; \n    vec3 halfVec = normalize(toEye + lightVector); \n \n    float roughnessFactor = (m + 8.0f) * pow(max(dot(halfVec, normal), 0.0f), m) / 8.0f; \n    vec3 fresnelFactor = SchlickFresnel(material.FresnelR0, halfVec, lightVector); \n    vec3 specAlbedo = fresnelFactor * roughnessFactor; \n \n    specAlbedo = specAlbedo / (specAlbedo + 1.0f); \n \n    return (material.DiffuseAlbedo.rgb + specAlbedo) * lightStrength; \n} \n \nvec3 ComputeDirectionalLight(Light light, Material material, vec3 normal, vec3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return vec3(0.0f, 0.0f, 0.0f); \n \n    vec3 lightVector = -light.Direction; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    vec3 lightStrength = light.Strength * ndotl; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nvec3 ComputePointLight(Light light, Material material, vec3 position, vec3 normal, vec3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return vec3(0.0f, 0.0f, 0.0f); \n \n    vec3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return vec3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    vec3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n \n    lightStrength = lightStrength * att; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nvec3 ComputeSpotLight(Light light, Material material, vec3 position, vec3 normal, vec3 toEye) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return vec3(0.0f, 0.0f, 0.0f); \n \n    vec3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return vec3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    vec3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n    lightStrength = lightStrength * att; \n \n    float spotFactor = pow(max(dot(-lightVector, light.Direction), 0.0f), light.SpotPower); \n \n    lightStrength = lightStrength * spotFactor; \n \n    return BlinnPhong(lightStrength, lightVector, normal, toEye, material); \n} \n \nvec4 ComputeLighting(Light lights[MAX_ALL_LIGHTS], Material material, vec3 position, vec3 normal, vec3 toEye) \n{ \n    normal = normalize(normal); \n \n    vec3 result = vec3(0.0f, 0.0f, 0.0f); \n \n    for (int i = 0; i < MAX_LIGHTS_PER_TYPE; i++) \n    { \n        result = result + ComputeDirectionalLight(lights[0 * MAX_LIGHTS_PER_TYPE + i], material, normal, toEye); \n        result = result + ComputePointLight(lights[1 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye); \n        result = result + ComputeSpotLight(lights[2 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye); \n    } \n \n    return vec4(result.xyz, material.DiffuseAlbedo.a); \n} \n \n \nlayout (set = 0, binding = 0) uniform Lights \n{ \n    Light instance[MAX_ALL_LIGHTS]; \n} lights; \n \nlayout (set = 0, binding = 1) buffer Materials \n{ \n    Material instance[]; \n} materials; \n \nlayout (set = 0, binding = 2) buffer Transform \n{ \n    Transform3D instance[]; \n} transforms; \n \nlayout (push_constant) uniform Index \n{ \n	float ambientLightRed; \n	float ambientLightGreen; \n	float ambientLightBlue; \n	float ambientLightAlpha; \n} index; \n \nlayout (location = 0) in vec3 viewPosition; \nlayout (location = 1) in vec3 position; \nlayout (location = 2) in vec3 normal; \nlayout (location = 3) in vec2 texcoord; \nlayout (location = 4) in vec3 tangent; \nlayout (location = 5) in flat uint instanceId; \n \nlayout (location = 0) out vec4 outColor; \n \nvoid main() \n{ \n    vec3 toEye = normalize(transforms.instance[instanceId].EyePosition.xyz - viewPosition); \n     \n	vec4 ambient = vec4( \n		index.ambientLightRed,  \n		index.ambientLightGreen,  \n		index.ambientLightBlue,  \n		index.ambientLightAlpha) * materials.instance[instanceId].DiffuseAlbedo; \n \n    outColor = ComputeLighting(lights.instance, materials.instance[instanceId], \n        position, normal, toEye) + ambient; \n \n    outColor.a = materials.instance[instanceId].DiffuseAlbedo.a; \n}\n";
	constexpr char DxPhysicallyBasedEffectPassVertexShaderCode[] = "#pragma pack_matrix(row_major) \n \nstruct Transform3D \n{ \n    matrix NormalTransform; \n    matrix Projection; \n    matrix Transform; \n    matrix View; \n	float4 EyePosition; \n}; \n \nstruct Output \n{ \n    float3 ViewPosition : POSITION0; \n    float4 SVPosition : SV_POSITION; \n    float3 Position : POSITION1; \n    float3 Normal : NORMAL; \n	float2 Texcoord : TEXCOORD; \n    float3 Tangent : TANGENT; \n	uint   InstanceId : SV_INSTANCEID; \n}; \n \nStructuredBuffer<Transform3D> transforms : register(t2, space0); \n \nOutput main( \n    float3 position : POSITION, \n    float3 normal : NORMAL, \n	float2 texcoord : TEXCOORD, \n    float3 tangent : TANGENT, \n	uint   instanceId : SV_INSTANCEID) \n{ \n    Output result; \n \n    result.Position = mul(float4(position, 1.0f), transforms[instanceId].Transform).xyz; \n    result.ViewPosition = mul(float4(result.Position, 1.0f), transforms[instanceId].View).xyz; \n    result.SVPosition = mul(float4(result.ViewPosition, 1.0f), transforms[instanceId].Projection); \n    result.Normal = mul(normal, (float3x3)transforms[instanceId].NormalTransform); \n    result.Tangent = mul(tangent, (float3x3)transforms[instanceId].NormalTransform); \n	result.Texcoord = texcoord; \n	result.InstanceId = instanceId; \n \n    return result; \n}\n";
	constexpr char VkPhysicallyBasedEffectPassVertexShaderCode[] = "#version 450 \n \n#extension GL_ARB_separate_shader_objects : enable \n \nstruct Transform3D \n{ \n    mat4 NormalTransform; \n    mat4 Projection; \n    mat4 Transform; \n    mat4 View; \n    vec4 EyePosition; \n}; \n \nlayout (set = 0, binding = 2) buffer Transform \n{ \n    Transform3D instance[]; \n} transforms; \n \nlayout (location = 0) in vec3 position; \nlayout (location = 1) in vec3 normal; \nlayout (location = 2) in vec2 texcoord; \nlayout (location = 3) in vec3 tangent; \n \nlayout (location = 0) out vec3 outViewPosition; \nlayout (location = 1) out vec3 outPosition; \nlayout (location = 2) out vec3 outNormal; \nlayout (location = 3) out vec2 outTexcoord; \nlayout (location = 4) out vec3 outTangent; \nlayout (location = 5) out uint outInstanceId; \n \nvoid main() \n{ \n    Transform3D transform = transforms.instance[gl_InstanceIndex]; \n \n    outPosition = (transform.Transform * vec4(position, 1.0)).xyz; \n    outViewPosition = (transform.View * vec4(outPosition, 1.0)).xyz; \n    outNormal = mat3(transform.NormalTransform) * normal; \n    outTangent = mat3(transform.NormalTransform) * tangent; \n    outTexcoord = texcoord; \n    outInstanceId = gl_InstanceIndex; \n \n    gl_Position = transform.Projection * vec4(outViewPosition, 1.0f); \n    gl_Position.y = -gl_Position.y; \n}\n";
	constexpr char DxPhysicallyBasedEffectPassPixelShaderCode[] = "#pragma pack_matrix(row_major) \n \n#define MAX_LIGHTS_PER_TYPE 16 \n#define MAX_ALL_LIGHTS MAX_LIGHTS_PER_TYPE * 3 \n \n#define MATERIAL_BUFFER 0 \n#define MATERIAL_TEXTURE 1 \n \n#define PI 3.14159265359 \n \nstruct Material \n{ \n    float4 DiffuseAlbedo; \n	float  Metallic; \n	float  Roughness; \n	float  AmbientOcclusion; \n    float  Unused; \n}; \n \nstruct Light { \n    float3 Strength; \n    float FalloffStart;  \n    float3 Direction;  \n    float FalloffEnd;  \n    float3 Position;  \n    float SpotPower;  \n}; \n \nstruct Transform3D \n{ \n	matrix NormalTransform; \n	matrix Projection; \n	matrix Transform; \n	matrix View; \n	float4 EyePosition; \n}; \n \n \nfloat3 mix(float3 x, float3 y, float3 a) \n{ \n    return x * (1.0 - a) + y * a; \n} \n \nfloat CalcAttenuation(float d, float falloffStart, float falloffEnd) \n{ \n    return saturate((falloffEnd - d) / (falloffEnd - falloffStart)); \n} \n \nfloat3 FresnelSchlick(float cosTheta, float3 F0) \n{ \n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0); \n} \n \nfloat DistributionGGX(float3 normal, float3 halfVector, float roughness) \n{ \n    float a = roughness * roughness; \n    float a2 = a * a; \n    float normalDotHalf = max(dot(normal, halfVector), 0.0); \n    float normalDotHalf2 = normalDotHalf * normalDotHalf; \n \n    float numerator = a2; \n    float denominator = (normalDotHalf2 * (a2 - 1.0) + 1.0); \n \n    denominator = PI * denominator * denominator; \n \n    return numerator / denominator; \n} \n \nfloat GeometrySchlickGGX(float normalDot, float roughness) \n{ \n    float r = (roughness + 1.0); \n    float k = (r * r) / 8.0; \n \n    float numerator = normalDot; \n    float denominator = normalDot * (1.0 - k) + k; \n \n    return numerator / denominator; \n} \n \nfloat GeometrySmith(float3 normal, float3 toEye, float3 lightVector, float roughness) \n{ \n    float normalDotEye = max(dot(normal, toEye), 0.0); \n    float normalDotLight = max(dot(normal, lightVector), 0.0); \n    float ggx2 = GeometrySchlickGGX(normalDotEye, roughness); \n    float ggx1 = GeometrySchlickGGX(normalDotLight, roughness); \n \n    return ggx1 * ggx2; \n} \n \nfloat3 CookTorranceBRDF(Material material, float3 radiance, float3 lightVector, float3 normal, float3 toEye, float3 F0) \n{ \n	//see https://github.com/JoeyDeVries/LearnOpenGL to learn more about PBR and BRDF \n    float3 halfVector = normalize(toEye + lightVector); \n \n    float  NDF = DistributionGGX(normal, halfVector, material.Roughness); \n    float  G = GeometrySmith(normal, toEye, lightVector, material.Roughness); \n    float3 F = FresnelSchlick(max(dot(halfVector, toEye), 0.0), F0); \n \n    float3 kS = F; \n    float3 kD = 1.0f - kS; \n \n    kD = kD * (1.0 - material.Metallic); \n \n    float3 numerator = NDF * G * F; \n    float denominator = 4.0 * max(dot(normal, toEye), 0.0) * max(dot(normal, lightVector), 0.0) + 0.001; \n \n    return (kD * material.DiffuseAlbedo.xyz / PI + numerator / denominator) * radiance; \n} \n \nfloat3 ComputeDirectionalLight(Light light, Material material, float3 normal, float3 toEye, float3 F0) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = -light.Direction; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    return CookTorranceBRDF(material, lightStrength, lightVector, normal, toEye, F0); \n} \n \nfloat3 ComputePointLight(Light light, Material material, float3 position, float3 normal, float3 toEye, float3 F0) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return float3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n \n    lightStrength = lightStrength * att; \n \n    return CookTorranceBRDF(material, lightStrength, lightVector, normal, toEye, F0); \n} \n \nfloat3 ComputeSpotLight(Light light, Material material, float3 position, float3 normal, float3 toEye, float3 F0) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return float3(0.0f, 0.0f, 0.0f); \n \n    float3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return float3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    float3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n    lightStrength = lightStrength * att; \n \n    float spotFactor = pow(max(dot(-lightVector, light.Direction), 0.0f), light.SpotPower); \n \n    lightStrength = lightStrength * spotFactor; \n \n    return CookTorranceBRDF(material, lightStrength, lightVector, normal, toEye, F0); \n} \n \nfloat4 ComputeLighting(Light lights[MAX_ALL_LIGHTS], Material material, float3 position, float3 normal, float3 toEye) \n{ \n    normal = normalize(normal); \n \n    float3 result = float3(0.0f, 0.0f, 0.0f); \n    float3 F0 = 0.04; \n \n    F0 = mix(F0, material.DiffuseAlbedo.xyz, material.Metallic); \n \n    for (int i = 0; i < MAX_LIGHTS_PER_TYPE; i++) \n    { \n        result = result + ComputeDirectionalLight(lights[0 * MAX_LIGHTS_PER_TYPE + i], material, normal, toEye, F0); \n        result = result + ComputePointLight(lights[1 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye, F0); \n        result = result + ComputeSpotLight(lights[2 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye, F0); \n    } \n \n    return float4(result.xyz, material.DiffuseAlbedo.a); \n} \n \nstruct Lights \n{ \n    Light instance[MAX_ALL_LIGHTS]; \n}; \n \nstruct Index \n{ \n	float ambientLightRed; \n	float ambientLightGreen; \n	float ambientLightBlue; \n	float ambientLightAlpha; \n	uint  materialType; \n}; \n \nStructuredBuffer<Transform3D> transforms : register(t2, space0); \nStructuredBuffer<Material> materials : register(t1, space0); \n \nConstantBuffer<Lights> lights : register(b0, space0); \nConstantBuffer<Index> index : register(b9, space0); \n \nTexture2D diffuseAlbedoTexture : register(t3, space0); \nTexture2D metallicTexture : register(t4, space0); \nTexture2D normalTexture : register(t5, space0); \nTexture2D roughnessTexture : register(t6, space0); \nTexture2D ambientOcclusionTexture : register(t7, space0); \n \nSamplerState materialSampler : register(s8, space0); \n \nfloat3 getNormalFromTexture(float3 normal, float2 texcoord, float3 tangent) \n{ \n    if (index.materialType == MATERIAL_BUFFER) return normal; \n \n    float3 tangentNormal = normalTexture.Sample(materialSampler, texcoord).xyz * 2.0 - 1.0; \n     \n    float3 N = normalize(normal); \n    float3 T = normalize(tangent - dot(tangent, N) * N); \n    float3 B = cross(N, T); \n    float3x3 TBN = float3x3(T, B, N); \n \n    return normalize(mul(tangentNormal, TBN)); \n} \n \nfloat4 main( \n    float3 viewPosition : POSITION0, \n    float4 sVPosition : SV_POSITION, \n    float3 position : POSITION1, \n    float3 normal : NORMAL, \n	float2 texcoord : TEXCOORD, \n    float3 tangent : TANGENT, \n	uint   instanceId : SV_INSTANCEID) : SV_TARGET \n{ \n    float3 toEye = normalize(transforms[instanceId].EyePosition.xyz - position); \n	 \n	Material material; \n	 \n	if (index.materialType == MATERIAL_BUFFER) \n		material = materials[instanceId]; \n	else \n	{ \n		material.DiffuseAlbedo = pow(diffuseAlbedoTexture.Sample(materialSampler, texcoord), 2.2); \n        material.Metallic = metallicTexture.Sample(materialSampler, texcoord).r; \n        material.Roughness = roughnessTexture.Sample(materialSampler, texcoord).r; \n        material.AmbientOcclusion = ambientOcclusionTexture.Sample(materialSampler, texcoord).r; \n	} \n \n \n	float4 ambient = float4( \n		index.ambientLightRed,  \n		index.ambientLightGreen,  \n		index.ambientLightBlue,  \n		index.ambientLightAlpha) * material.DiffuseAlbedo * material.AmbientOcclusion; \n \n    float4 color = ComputeLighting(lights.instance, material, \n        position, getNormalFromTexture(normal, texcoord, tangent), toEye) + ambient; \n \n    color = color / (color + 1.0f); \n    color = pow(color, 1.0 / 2.2); \n \n	return float4(color.xyz, material.DiffuseAlbedo.a); \n}\n";
	constexpr char VkPhysicallyBasedEffectPassPixelShaderCode[] = "#version 450 \n \n#extension GL_ARB_separate_shader_objects : enable \n \n#define MAX_LIGHTS_PER_TYPE 16 \n#define MAX_ALL_LIGHTS MAX_LIGHTS_PER_TYPE * 3 \n \n#define MATERIAL_BUFFER 0 \n#define MATERIAL_TEXTURE 1 \n \n#define PI 3.14159265359 \n \nstruct Material \n{ \n    vec4 DiffuseAlbedo; \n	float  Metallic; \n	float  Roughness; \n	float  AmbientOcclusion; \n    float  Unused; \n}; \n \nstruct Light { \n    vec3 Strength; \n    float FalloffStart;  \n    vec3 Direction;  \n    float FalloffEnd;  \n    vec3 Position;  \n    float SpotPower;  \n}; \n \nstruct Transform3D \n{ \n    mat4 NormalTransform; \n    mat4 Projection; \n    mat4 Transform; \n    mat4 View; \n    vec4 EyePosition; \n}; \n \nvec3 mix0(vec3 x, vec3 y, vec3 a) \n{ \n    return x * (1.0 - a) + y * a; \n} \n \nfloat CalcAttenuation(float d, float falloffStart, float falloffEnd) \n{ \n    return clamp((falloffEnd - d) / (falloffEnd - falloffStart), 0, 1); \n} \n \nvec3 FresnelSchlick(float cosTheta, vec3 F0) \n{ \n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0); \n} \n \nfloat DistributionGGX(vec3 normal, vec3 halfVector, float roughness) \n{ \n    float a = roughness * roughness; \n    float a2 = a * a; \n    float normalDotHalf = max(dot(normal, halfVector), 0.0); \n    float normalDotHalf2 = normalDotHalf * normalDotHalf; \n \n    float numerator = a2; \n    float denominator = (normalDotHalf2 * (a2 - 1.0) + 1.0); \n \n    denominator = PI * denominator * denominator; \n \n    return numerator / denominator; \n} \n \nfloat GeometrySchlickGGX(float normalDot, float roughness) \n{ \n    float r = (roughness + 1.0); \n    float k = (r * r) / 8.0; \n \n    float numerator = normalDot; \n    float denominator = normalDot * (1.0 - k) + k; \n \n    return numerator / denominator; \n} \n \nfloat GeometrySmith(vec3 normal, vec3 toEye, vec3 lightVector, float roughness) \n{ \n    float normalDotEye = max(dot(normal, toEye), 0.0); \n    float normalDotLight = max(dot(normal, lightVector), 0.0); \n    float ggx2 = GeometrySchlickGGX(normalDotEye, roughness); \n    float ggx1 = GeometrySchlickGGX(normalDotLight, roughness); \n \n    return ggx1 * ggx2; \n} \n \nvec3 CookTorranceBRDF(Material material, vec3 radiance, vec3 lightVector, vec3 normal, vec3 toEye, vec3 F0) \n{ \n	//see https://github.com/JoeyDeVries/LearnOpenGL to learn more about PBR and BRDF \n    vec3 halfVector = normalize(toEye + lightVector); \n \n    float  NDF = DistributionGGX(normal, halfVector, material.Roughness); \n    float  G = GeometrySmith(normal, toEye, lightVector, material.Roughness); \n    vec3 F = FresnelSchlick(max(dot(halfVector, toEye), 0.0), F0); \n \n    vec3 kS = F; \n    vec3 kD = 1.0f - kS; \n \n    kD = kD * (1.0 - material.Metallic); \n \n    vec3 numerator = NDF * G * F; \n    float denominator = 4.0 * max(dot(normal, toEye), 0.0) * max(dot(normal, lightVector), 0.0) + 0.001; \n \n    return (kD * material.DiffuseAlbedo.xyz / PI + numerator / denominator) * radiance; \n} \n \nvec3 ComputeDirectionalLight(Light light, Material material, vec3 normal, vec3 toEye, vec3 F0) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return vec3(0.0f, 0.0f, 0.0f); \n \n    vec3 lightVector = -light.Direction; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    vec3 lightStrength = light.Strength * ndotl; \n \n    return CookTorranceBRDF(material, lightStrength, lightVector, normal, toEye, F0); \n} \n \nvec3 ComputePointLight(Light light, Material material, vec3 position, vec3 normal, vec3 toEye, vec3 F0) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return vec3(0.0f, 0.0f, 0.0f); \n \n    vec3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return vec3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    vec3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n \n    lightStrength = lightStrength * att; \n \n    return CookTorranceBRDF(material, lightStrength, lightVector, normal, toEye, F0); \n} \n \nvec3 ComputeSpotLight(Light light, Material material, vec3 position, vec3 normal, vec3 toEye, vec3 F0) \n{ \n    if (light.Strength.x == 0 && light.Strength.y == 0 && light.Strength.z == 0) return vec3(0.0f, 0.0f, 0.0f); \n \n    vec3 lightVector = light.Position - position; \n    float d = length(lightVector); \n \n    if (d > light.FalloffEnd) return vec3(0.0f, 0.0f, 0.0f); \n \n    lightVector = lightVector / d; \n \n    float ndotl = max(dot(lightVector, normal), 0.0f); \n    vec3 lightStrength = light.Strength * ndotl; \n \n    float att = CalcAttenuation(d, light.FalloffStart, light.FalloffEnd); \n    lightStrength = lightStrength * att; \n \n    float spotFactor = pow(max(dot(-lightVector, light.Direction), 0.0f), light.SpotPower); \n \n    lightStrength = lightStrength * spotFactor; \n \n    return CookTorranceBRDF(material, lightStrength, lightVector, normal, toEye, F0); \n} \n \nvec4 ComputeLighting(Light lights[MAX_ALL_LIGHTS], Material material, vec3 position, vec3 normal, vec3 toEye) \n{ \n    normal = normalize(normal); \n \n    vec3 result = vec3(0.0f, 0.0f, 0.0f); \n    vec3 F0 = vec3(0.04); \n \n    F0 = mix0(F0, material.DiffuseAlbedo.xyz, vec3(material.Metallic)); \n \n    for (int i = 0; i < MAX_LIGHTS_PER_TYPE; i++) \n    { \n        result = result + ComputeDirectionalLight(lights[0 * MAX_LIGHTS_PER_TYPE + i], material, normal, toEye, F0); \n        result = result + ComputePointLight(lights[1 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye, F0); \n        result = result + ComputeSpotLight(lights[2 * MAX_LIGHTS_PER_TYPE + i], material, position, normal, toEye, F0); \n    } \n \n    return vec4(result.xyz, material.DiffuseAlbedo.a); \n} \n \nlayout (set = 0, binding = 0) uniform Lights \n{ \n    Light instance[MAX_ALL_LIGHTS]; \n} lights; \n \nlayout (set = 0, binding = 1) buffer Materials \n{ \n    Material instance[]; \n} materials; \n \nlayout (set = 0, binding = 2) buffer Transform \n{ \n    Transform3D instance[]; \n} transforms; \n \nlayout (push_constant) uniform Index \n{ \n	float ambientLightRed; \n	float ambientLightGreen; \n	float ambientLightBlue; \n	float ambientLightAlpha; \n    uint  materialType; \n} index; \n \nlayout (location = 0) in vec3 viewPosition; \nlayout (location = 1) in vec3 position; \nlayout (location = 2) in vec3 normal; \nlayout (location = 3) in vec2 texcoord; \nlayout (location = 4) in vec3 tangent; \nlayout (location = 5) in flat uint instanceId; \n \nlayout (location = 0) out vec4 outColor; \n \nlayout (set = 0, binding = 3) uniform texture2D diffuseAlbedoTexture; \nlayout (set = 0, binding = 4) uniform texture2D metallicTexture; \nlayout (set = 0, binding = 5) uniform texture2D normalTexture; \nlayout (set = 0, binding = 6) uniform texture2D roughnessTexture; \nlayout (set = 0, binding = 7) uniform texture2D ambientOcclusionTexture; \n \nlayout (set = 0, binding = 8) uniform sampler materialSampler; \n \nvec3 getNormalFromTexture(vec3 normal, vec2 texcoord, vec3 tangent) \n{ \n    if (index.materialType == MATERIAL_BUFFER) return normal; \n \n    vec3 tangentNormal = texture(sampler2D(normalTexture, materialSampler), texcoord).xyz * 2.0 - 1.0; \n     \n    vec3 N = normalize(normal); \n    vec3 T = normalize(tangent - dot(tangent, N) * N); \n    vec3 B = cross(N, T); \n    mat3 TBN = mat3(T, B, N); \n \n    return normalize(TBN * tangentNormal); \n} \n \nvoid main() \n{ \n    vec3 toEye = normalize(transforms.instance[instanceId].EyePosition.xyz - position); \n	 \n	Material material; \n	 \n	if (index.materialType == MATERIAL_BUFFER) \n		material = materials.instance[instanceId]; \n	else \n	{ \n		material.DiffuseAlbedo = pow(texture(sampler2D(diffuseAlbedoTexture, materialSampler), texcoord), vec4(2.2)); \n        material.Metallic = texture(sampler2D(metallicTexture, materialSampler), texcoord).r; \n        material.Roughness = texture(sampler2D(roughnessTexture, materialSampler), texcoord).r; \n        material.AmbientOcclusion = texture(sampler2D(ambientOcclusionTexture, materialSampler), texcoord).r; \n	} \n \n	vec4 ambient = vec4( \n		index.ambientLightRed,  \n		index.ambientLightGreen,  \n		index.ambientLightBlue,  \n		index.ambientLightAlpha) * material.DiffuseAlbedo * material.AmbientOcclusion; \n \n    vec4 color = ComputeLighting(lights.instance, material, \n        position, getNormalFromTexture(normal, texcoord, tangent), toEye) + ambient; \n \n    color = color / (color + vec4(1.0f)); \n    color = pow(color, vec4(1.0 / 2.2)); \n \n	outColor = vec4(color.xyz, material.DiffuseAlbedo.a); \n}\n";

}